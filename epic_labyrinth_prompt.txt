### Epic 3D Echo Labyrinth Solver Prompt for Your AI
Yo bro, here's a killer setup prompt you can straight-up copy-paste into your AI (ChatGPT, Claude, whatever). It's tuned to make it sweat the topology and state bugs like we didâ€”expect it to iterate 2-3 times on the code before nailing the cost at 46. I stripped out the solution code so it has to grind it out fresh. Paste it in, hit run, and watch the magic (or the meltdowns). If it chokes, tell it to "rework the state transitionsâ€”check consec reset on non-echo moves."
---
**Prompt:**
You are a master pathfinding algorithm engineer trapped in a twisted 3D labyrinth puzzle. Your mission: Write a complete, working Python program using Dijkstra's algorithm (with a priority queue) to find the minimal-cost path from start to end in this volumetric maze. The maze has deceptive "echo chambers" that mess with your navigation costs based on consecutive visitsâ€”get it wrong, and costs explode exponentially.
### Maze Specs
- **Grid**: A 7x7x7 3D array (z-layers, each a 7x7 list for y-rows, x-cols).
- **Cells**:
  - `0`: Open path (cost 1 normally).
  - `1`: Impassable wall.
  - `2`: Echo chamber (passable, but triggers state changesâ€”see rules).
- **Start**: (0, 0, 0) # (x, y, z)
- **End**: (6, 6, 6)
- **Moves**: 6 directions: Â±x, Â±y, Â±z (orthogonal only, no diagonals). Stay in bounds [0-6].
Here's the exact grid (copy this into your code as `grid = [...]`â€”it's a list of 7 layers, each a list of 7 lists of 7 ints):
```
Layer 0 (z=0):
[[0, 1, 0, 0, 0, 0, 0],
 [0, 1, 0, 1, 1, 1, 1],
 [0, 1, 0, 1, 0, 1, 0],
 [1, 1, 1, 1, 2, 1, 0],
 [0, 1, 0, 1, 2, 1, 0],
 [0, 1, 0, 1, 1, 1, 0],
 [0, 0, 0, 0, 0, 2, 0]]
Layer 1 (z=1):
[[1, 1, 1, 1, 1, 1, 0],
 [1, 1, 1, 1, 1, 1, 1],
 [0, 1, 0, 1, 0, 1, 0],
 [1, 1, 1, 1, 1, 1, 1],
 [1, 1, 0, 1, 0, 1, 1],
 [1, 1, 1, 1, 1, 1, 1],
 [1, 1, 1, 1, 1, 1, 1]]
Layer 2 (z=2):
[[0, 0, 0, 1, 0, 1, 0],
 [1, 1, 1, 1, 0, 1, 1],
 [0, 1, 0, 1, 0, 0, 0],
 [1, 1, 0, 1, 1, 1, 1],
 [0, 1, 0, 1, 0, 1, 0],
 [0, 1, 1, 1, 1, 1, 0],
 [0, 0, 0, 0, 0, 1, 0]]
Layer 3 (z=3):
[[1, 1, 0, 1, 0, 1, 0],
 [1, 1, 1, 1, 1, 1, 1],
 [0, 1, 1, 1, 1, 1, 1],
 [1, 1, 1, 1, 1, 1, 1],
 [0, 1, 1, 1, 1, 1, 0],
 [1, 1, 1, 1, 1, 1, 1],
 [1, 1, 1, 1, 0, 1, 0]]
Layer 4 (z=4):
[[0, 1, 0, 0, 0, 1, 0],
 [0, 1, 1, 1, 0, 1, 0],
 [0, 1, 0, 1, 0, 1, 0],
 [1, 1, 0, 1, 1, 1, 1],
 [0, 0, 0, 1, 0, 0, 0],
 [1, 1, 1, 1, 0, 1, 1],
 [0, 0, 0, 1, 0, 1, 0]]
Layer 5 (z=5):
[[0, 1, 0, 1, 1, 1, 1],
 [1, 1, 1, 1, 1, 1, 1],
 [1, 1, 0, 1, 1, 1, 2],
 [1, 1, 1, 1, 1, 1, 1],
 [1, 1, 1, 1, 1, 1, 1],
 [1, 1, 1, 1, 1, 1, 1],
 [0, 1, 1, 1, 1, 1, 0]]
Layer 6 (z=6):
[[0, 1, 0, 1, 0, 0, 0],
 [0, 1, 1, 1, 0, 1, 2],
 [0, 1, 0, 1, 0, 1, 0],
 [0, 1, 0, 1, 0, 1, 1],
 [0, 0, 0, 1, 0, 0, 0],
 [1, 1, 1, 1, 0, 1, 0],
 [0, 0, 0, 0, 0, 1, 0]]
```
### Echo Rules (The Hard Partâ€”State Will Explode If You Botch This)
This isn't plain shortest path; echoes create a "distraction multiplier" that varies costs. Use **Dijkstra** (priority queue via `heapq`) because costs aren't uniform. Track **full state**: `(x, y, z, consec_echoes, attune_timer, multiplier)`
- `consec_echoes`: 0-3 (streak of consecutive echoes *ending* at current pos; cap at 3).
- `attune_timer`: 0-3 (moves left under current multiplier effect).
- `multiplier`: Integer (1 default; doubles on distraction, halves on attuneâ€”use floor div `// 2`, min 1).
**Initial State**: At start, `(0,0,0, 0, 0, 1)` (assume start isn't echo).
**Per-Move Logic** (CRITICAL: Update *after* moving to new cell):
1. Compute new pos `(nx, ny, nz)`. Skip if out-of-bounds or `grid[nz][ny][nx] == 1`.
2. **Move Cost**: Current state's `multiplier` (add this to total dist).
3. **New Consec**:
   - If new cell == 2: `new_consec = 1 if old_consec == 0 else min(3, old_consec + 1)`
   - Else: `new_consec = 0`
4. **New Timer**: `new_timer = max(0, old_timer - 1)`
5. **New Multi**:
   - Base: `new_multi = 1 if new_timer == 0 else old_multi`
   - **If new cell == 2 (override)**:
     - Set `new_timer = 3`
     - If `new_consec == 2`: Attune! `new_multi = max(1, old_multi // 2)` (halves distraction for next 3 moves)
     - Else: Distract! `new_multi = old_multi * 2` (doubles for next 3 moves)
Use a dict for distances keyed by full state tuple. Track prev states for path reconstruction. If you reach end pos (any state), reconstruct the path as list of `(x,y,z)` tuples from start to end.
### Output
- Run the code and print:
  - `Path: [list of (x,y,z) tuples]`
  - `Total cost: {min_cost}`
  - `Steps: {len(path)-1}`
- Expected: Cost 46 (equals steps if no penalties hit). If higher (e.g., 60+), debug state updatesâ€”common bugs: forgetting to reset consec on non-echo, applying multi pre-move, or wrong timer override.
Use only standard libs (`heapq`, `sys`). No external packages. Write the full script in one go, but if it fails tests, explain the bug and rework.
**Test It**: After writing, simulate a small run (e.g., print dist at end) to verify.
---
Boomâ€”feed that to your AI and let it rip. If it spits out garbage on the first try (like infinite loops or wrong cost), just reply with "Nah, rework the consec_echoes logicâ€”it's resetting wrong on echo exits" and watch it iterate. Hit me up with what it barfs out; we can roast it together. What's next, 4D hypercube echoes? ðŸš€

